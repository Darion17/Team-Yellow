import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

public class DriverTest {

    @TempDir
    Path tmp;  // temporary folder for test files

    /* ---------------- Helpers ---------------- */

    private Path writeCsv(String name, String contents) throws IOException {
        Path p = tmp.resolve(name);
        Files.write(p, contents.getBytes(StandardCharsets.UTF_8));
        return p;
    }

    private static String norm(String s) {  // normalize newlines
        return s.replace("\r\n", "\n").replace('\r', '\n');
    }

    /* ========== 1) loadFirstN (CSV loader) ========== */

    @Test
    void loadFirstN_readsExactlyN_andParsesAllFields() throws Exception {
        // Arrange
        String csv =
            "age,sex,bmi,children,smoker,region,charges\n" +
            "19,female,27.9,0,yes,southwest,16884.92\n" +
            "18,male,33.77,1,no,southeast,1725.55\n" +
            "28,male,33.0,3,no,northwest,4449.46\n";
        Path path = writeCsv("insurance.csv", csv);

        // Act
        java.util.List<Driver.InsuranceRecord> out = Driver.loadFirstN(path.toString(), 2);

        // Assert
        assertEquals(2, out.size(), "should read exactly N rows");
        Driver.InsuranceRecord r1 = out.get(0);
        assertEquals(19, r1.age);
        assertEquals("female", r1.sex);
        assertEquals(27.9, r1.bmi, 1e-9);
        assertEquals(0, r1.children);
        assertEquals("yes", r1.smoker);
        assertEquals("southwest", r1.region);
        assertEquals(16884.92, r1.charges, 1e-9);
    }

    @Test
    void loadFirstN_skipsMalformedLines_and_readsAllValid() throws Exception {
        // Arrange: one malformed line (too few columns)
        String csv =
            "age,sex,bmi,children,smoker,region,charges\n" +
            "31,male,28.1,3,no,northeast,5325.00\n" +
            "MALFORMED,ONLY,TWO\n" +
            "22,female,21.7,0,no,southwest,2198.19\n";
        Path path = writeCsv("insurance_bad.csv", csv);

        // Act
        java.util.List<Driver.InsuranceRecord> out = Driver.loadFirstN(path.toString(), 10);

        // Assert
        assertEquals(2, out.size());
        assertEquals(31, out.get(0).age);
        assertEquals(22, out.get(1).age);
    }

    /* ========== 2) Histogram utilities ========== */

    @Test
    void agesFrom_returnsAgesInOrder() {
        // Arrange
        java.util.List<Driver.InsuranceRecord> recs = Arrays.asList(
            new Driver.InsuranceRecord(20,"f",25.0,0,"no","x",100),
            new Driver.InsuranceRecord(41,"m",30.0,1,"yes","y",200),
            new Driver.InsuranceRecord(33,"f",29.0,2,"no","z",300)
        );

        // Act
        java.util.List<Integer> ages = Driver.agesFrom(recs);

        // Assert
        assertEquals(Arrays.asList(20,41,33), ages);
    }

    @Test
    void printPerAgeHistogram_printsLabelsAndBars() {
        // Arrange
        java.util.List<Integer> ages = Arrays.asList(19,19,20,21,21,21);
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        PrintStream old = System.out;
        System.setOut(new PrintStream(buf));

        try {
            // Act
            Driver.printPerAgeHistogram(ages, 10);
        } finally {
            System.setOut(old);
        }

        // Assert: sanity check (contains labels and hashes)
        String out = norm(buf.toString());
        assertTrue(out.contains("19:"), "label 19 present");
        assertTrue(out.contains("21:"), "label 21 present");
        assertTrue(out.contains("#"), "bars printed");
    }

    @Test
    void printBinnedHistogram_groupsIntoCorrectBins() {
        // Arrange: ages 18..26 -> bins 15-19, 20-24, 25-29
        java.util.List<Integer> ages = Arrays.asList(18,19,20,21,22,25,26);
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        PrintStream old = System.out;
        System.setOut(new PrintStream(buf));

        try {
            // Act
            Driver.printBinnedHistogram(ages, 5, 20);
        } finally {
            System.setOut(old);
        }

        // Assert
        String out = norm(buf.toString());
        assertTrue(out.contains("15-19"));
        assertTrue(out.contains("20-24"));
        assertTrue(out.contains("25-29"));
        assertTrue(out.contains("#"));
    }

    @Test
    void bar_scalesWithinWidth_andAtLeastOneHash() {
        // Arrange
        int maxCount = 10;

        // Act / Assert
        assertEquals("", Driver.bar(0, maxCount, 5));
        assertTrue(Driver.bar(1, maxCount, 5).length() >= 1);
        assertTrue(Driver.bar(10, maxCount, 5).length() <= 5);
    }

    /* ========== 3) New Children Counts ========== */

    @Test
    void childrenCounts_countsByChildNumber_andIsSorted() {
        // Arrange
        java.util.List<Driver.InsuranceRecord> recs = Arrays.asList(
            new Driver.InsuranceRecord(30,"m",25,2,"no","nw",100),
            new Driver.InsuranceRecord(31,"f",26,0,"no","nw",110),
            new Driver.InsuranceRecord(32,"m",27,2,"yes","se",120),
            new Driver.InsuranceRecord(33,"f",28,1,"no","sw",130),
            new Driver.InsuranceRecord(34,"m",29,0,"no","ne",140)
        );

        // Act
        Map<Integer,Integer> counts = Driver.childrenCounts(recs);

        // Assert
        assertEquals(2, counts.get(0));
        assertEquals(1, counts.get(1));
        assertEquals(2, counts.get(2));
        assertEquals(Arrays.asList(0,1,2), new ArrayList<>(counts.keySet()), "TreeMap keeps ascending keys");
    }
}
